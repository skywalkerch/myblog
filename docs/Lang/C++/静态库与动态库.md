> 一直以来我对C系列语言的系统级编程都没有什么经验，每次安装windows软件都会遇到dll，在Linux下编程时也会遇到libxxx缺失等等问题，一直以来都没有对这方面彻底弄懂。正好可以趁这个寒假的机会多写几篇博客彻底弄懂这些有趣的东西，给自己的编程之旅打下基础。
> 

# 前言–hello.c文件的编译过程

![https://picbed-1303839378.cos.ap-nanjing.myqcloud.com/picbed/202201181052594.png](https://picbed-1303839378.cos.ap-nanjing.myqcloud.com/picbed/202201181052594.png)

这张图片介绍了一个`hello.c`源文件是怎么一步步成为一个二进制可执行文件的。

## 第一步–预处理(**Pre-processor**)

**预处理**的过程中预处理器会读取`hello.c`文件中所有`#`标记的语句,包括`#include<xxx>`,以及`#define xx xx`，预处理器会将把`#include <xxx>`涉及到的头文件的所有内容全部复制并将源文件中的`#include<xxx>`用所复制内容的替换,同时预处理也会把所有涉及到宏定义的语句全部替换成宏定义后指定的字符串内容(**宏定义都是用对应字符串替换原内容**),这时经过修改后`hello.c`文件变为了`hello.i`

## 第二步–编译(**Compile**)

编译阶段编译器(eg:gcc)则会将`hello.i`文件编译成汇编文件。编译结果是`hello.s`，是一个包含汇编代码的文件

## 第三步–汇编(**Assemble**)

汇编器会把`hello.s`里的内容汇编成一个机器指令，然后打包这些机器指令到一个文件中`hello.o`，这是一个二进制文件，如果用编辑器打开的话里面都是0和1，非专业人士很难看懂(`gibberish`)

## 第四步–链接(**Link**)

链接器所做的事就是将**静态库** **动态库**，以及其他`.o`文件链接起来一起编译出来一个可执行文件,在Linux中，最终结果为`hello`，在windows中这个最终结果叫`hello.exe`

> 而这篇博客要详细介绍的就是链接这个阶段涉及到的静态库与动态库
> 

# 静态库(**static library**)

在计算机科学中，**静态库**（英语：Static library, Statically-linked library），或称**静态库**，是一个外部函数与变量的集合体。静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。而这个可执行文件与编译可执行文件的程序，都是一种程序的静态创建（static build）。以过去的观点来说，库只能算是静态（static）类型。

这段话来自于维基百科,可以看出静态库的以下特点: - 静态库是一个二进制的**外部**函数与变量的集合 - 工作于链接期间 - 用于制作其他目标文件或者可执行的二进制文件

## 静态库的优点

- 代码装载速度快，执行速度略比动态链接库快；
- 只需保证在开发者的计算机中有正确的.lib(linux下是.a)文件，在以二进制形式发布程序时不需考虑在用户的计算机上.lib文件是否存在及版本问题，可避免[dll地狱](https://en.wikipedia.org/wiki/DLL_Hell)等问题；

## 静态库的缺点

- 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；

## 静态库的创建

- 第一步：编辑静态库的源文件`sort.c`
- 第二步：将`sort.c`编译成`sort.o`文件`gcc -c sort.c`
- 第三步：创建静态库并将目标文件加入到库中 `ar -r libmath.a sort.c`

## 静态库的使用

### 方法一：参数法

格式：`gcc 主程序 -l 静态库名(去掉lib和.a) -L 静态库存放的位置`

### 方法二：直接法

格式：`gcc 主程序 静态库全名`

## ar用法

- -r 将目标文件加入到静态库中
- -t 显示静态库中的文件
- -a 将目标文件追加到静态库文件现有文件之后
- -b 将目标文件追加到静态库文件现有文件之后
- -d 从指定的静态库中删除目标文件
- -x 从指定的静态库中提取目标文件
- -p 把静态库文件中指定的问及那输出到标准输出
- -q 快速地把文件追加到静态库中

# 动态库

动态库又叫共享库，编译时链接动态库，但不加载目标代码，只有在运行时才加载相关的目标代码（所调用的库函数）到内存，进程结束时自动释放其所占内存空间。

## 动态库的创建

仍以sort.c为例

- 第一步：编辑sort.c文件
- 第二步：生成sort.o文件 `gcc -c -fpic sort.c`
- 第三步：`gcc -shared sort.o -o libsort.so`
- 也可以第二步第三步合并：`gcc -shared -fpic sort.c -o libsort.so`

## 动态库的使用

### 方法一：参数法

格式：`gcc 主程序 -l 动态库名(去掉lib和so) -L 动态库的存储位置`

### 方法二：直接法

格式：`gcc 主程序 动态库全名`

## 动态库的优点

- 更加节省内存并减少页面交换；
- DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；
- 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；
- 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

## 动态库的缺点

- 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。

# 静态库与动态库的区别

- 静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要该静态库。编译之后程序的大小比较大，但是隔离性好
- 动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要该动态库文件存在。编译后的程序文件相对较小，多个应用程序可以使用同一个动态库，启动多个应用程序时，只需要将动态库加载到内存一次即可。